# Julian Q. Zhou
# https://github.com/julianqz

# prep for alluvial plot and paired within-clone SHM frequency plot between labels

#' generate an alluvial-plot-ready data.frame
#'
#' @params  alluv_cols         A vector of sequence labels to consider.
#'                             E.g. timepoint-compartment combinations.
#' @params  df_clone_info      A data.frame containing summary info of clones.
#'                             This is expected to have been generated by 
#'                             `summarize_clone`.
#' @params  col_df_clone_id    Column name in `df_clone_info` containing clone IDs.
#' @params  vec_overlap_regex  Optional. A vector containing regex patterns 
#'                             which, when applied to `alluv_cols`, can unambiguously
#'                             determine whether there's overlap between labels.
#' 
#' @returns
#' 
#' A list containing
#' - `alluv_df`: A data.frame. 
#'               Columns are made of `alluv_cols`, `count`, and `overlap`.
#'               Rows represent exhaustive combinations of T or F for each label 
#'               in `alluv_cols`.
#'               The `count` column records the number of clones fulfilling the 
#'               description in each row.
#'               The `overlap` column records whether clones fulling the description
#'               of a given row is considered to contain overlap as defined by
#'               `vec_overlap_regex`.
#' 
#' - `alluv_lst_cl_id`: A list. List length matches nrow of `alluv_df`.
#'                      Each list entry corresponds to a row in `alluv_df` and
#'                      records the clone IDs from `df_clone_info`, if any, 
#'                      of the clones fulfilling the description of that row in 
#'                      `alluv_df`. 
#'                      The number of clone IDs in each list entry matches the value
#'                      in the `count` column in `alluv_df`.
#'                      
#' @details
#' 
#' Each label in `alluv_cols` should correspond to a column in
#' `df_clone_info` with the same name.
#'
#' If `vec_overlap_regex` is defined, boolean values will be recorded in the
#' `overlap` column in the returned data.frame. Otherwise, all values in the 
#' `overlap` columns will be `NA`.
#'
#' @examples
#' alluv_cols =  c(paste0("PB_", c("d28")),
#'                 paste0("GC_d", c(28,35,60,110,201)))
#' 
#' df_clone_info = clone_info
#' 
#' vec_overlap_regex = c("GC_", "PB_")
#' 
#' prep_for_alluv(alluv_cols, df_clone_info, "clone_id_2", vec_overlap_regex)
#' 
prep_for_alluv = function(alluv_cols, df_clone_info, col_df_clone_id,
                          vec_overlap_regex=NULL) {
    
    stopifnot(all(alluv_cols %in% colnames(df_clone_info)))
    
    # create a list
    # list length matches that of alluv_cols
    # each entry is c(T,F)
    # to be used as input for expand.grid
    alluv_lst = lapply(1:length(alluv_cols), function(x){c(T,F)})
    
    # binary matrix
    # all combinations of whether each compartment-timepoint is present
    alluv_df = expand.grid(alluv_lst)
    stopifnot(nrow(alluv_df)==2^(length(alluv_cols)))
    colnames(alluv_df) = alluv_cols
    
    # vector to record clone counts
    alluv_vec = rep(NA, nrow(alluv_df))
    # list to record clone IDs
    # one list entry for each row of binary matrix
    alluv_lst_cl_id = vector(mode="list", length=nrow(alluv_df))
    # index wrt clone_info
    alluv_lst_cl_idx = vector(mode="list", length=nrow(alluv_df))
    
    for (i in 1:nrow(alluv_df)) {
        if (any(alluv_df[i, ])) {
            # at least 1 T
            
            # TRUE columns 
            cur_cols_t = colnames(alluv_df)[which(alluv_df[i, ]==TRUE)]
            # FALSE columns
            cur_cols_f = colnames(alluv_df)[which(alluv_df[i, ]==FALSE)]
            
            stopifnot(length(cur_cols_t)>0)
            
            # each entry corresponds to a clone in clone_info
            # for a given clone, T if that clone has seq in all cur_cols_t columns
            if (length(cur_cols_t)>1) {
                bool_t = rowSums(df_clone_info[, cur_cols_t]>0)==length(cur_cols_t)
            } else {
                bool_t = df_clone_info[, cur_cols_t]>0
            }
            
            # if no FALSE column
            if (length(cur_cols_f)>0) {
                if (length(cur_cols_f)>1) {
                    bool_f = rowSums(df_clone_info[, cur_cols_f]==0)==length(cur_cols_f)
                } else {
                    bool_f = df_clone_info[, cur_cols_f]==0
                }
                
            } else {
                bool_f = rep(T, nrow(df_clone_info))
            }
            
            bool = bool_t & bool_f
        } else {
            # all F
            bool = rowSums(df_clone_info[, colnames(alluv_df)]==0) == length(alluv_cols)
            
        }
        # record clone count
        alluv_vec[i] = sum(bool)
        # record clone IDs and index wrt clone_info
        alluv_lst_cl_id[[i]] = df_clone_info[[col_df_clone_id]][bool]
        alluv_lst_cl_idx[[i]] = which(bool)
    }
    
    stopifnot( sum(alluv_vec) == nrow(df_clone_info) )
    stopifnot(all.equal( alluv_vec, 
                         unlist(lapply(alluv_lst_cl_id, length)) ))
    stopifnot(all.equal( alluv_vec, 
                         unlist(lapply(alluv_lst_cl_idx, length)) ))
    
    alluv_df[["count"]] = alluv_vec
    
    if (!is.null(vec_overlap_regex)) {
        
        lst_alluv_row_bool = lapply(vec_overlap_regex, function(s){
            
            cur_alluv_cols = colnames(alluv_df)[grep(pattern=s, x=colnames(alluv_df))]
            
            if (length(cur_alluv_cols)>1) {
                cur_alluv_row_bool = apply(alluv_df[, cur_alluv_cols], 1, any)
            } else {
                cur_alluv_row_bool = alluv_df[, cur_alluv_cols]
            }
            
            return(cur_alluv_row_bool)
        })
        df_alluv_row_bool = do.call(cbind, lst_alluv_row_bool)
        
        # apply `and` across
        alluv_row_bool = rowSums(df_alluv_row_bool)==ncol(df_alluv_row_bool)
        
        alluv_df[["overlap"]] = alluv_row_bool
        
    } else {
        alluv_df[["overlap"]] = NA
    }
    

    return(list(alluv_df=alluv_df,
                alluv_lst_cl_id=alluv_lst_cl_id))
}



#' Generate a data.frame for plotting median clonal mutation of PAIRED labels
#' For clones containing BOTH a_ident and b_ident
#' 
#' @params  lst_pairs         A list containing vector(s) of length 2.
#'                            Eg: `list(c("PB_d28, "GC_d28"), c("PB_d28", "GC_d35"))`
#' @params  alluv_cols        A vector of sequence labels. 
#'                            Same the input for `prep_for_alluv`.
#' @params  alluv_df          A data.frame outputted by `prep_for_alluv`.
#' @params  alluv_lst_cl_id   A list outputted by `prep_for_alluv`.
#' @params  df_data           A data.frame containing sequence data.
#' @params  col_df_clone_id   Column name `df_data` containing clone IDs.
#' @params  col_df_mf         Column name `df_data` containing SHM frequency.
#' @params  col_df_label      Column name `df_data` containing the labels in `alluv_cols`.
#' 
#' @returns
#' A list of 1 vector and 2 data.frames, one in long format and the other in wide format. 
#' 
#' The vector is a result of concatenating `lst_pairs` by ` + `.
#' 
#' Wide format columns: 
#' `facet`, `clone_id`, `a_ident`, `b_ident`, `a_val`, `b_val`
#' `[ab]_ident` are labels in `lst_pairs` 
#' `facet` is simply `a_ident` + `b_ident`
#' For a given clone, `[ab]_val` are the median SHM frequency of sequences corresponding
#' to labels `[ab]_ident` resp.
#'
#' Long format columns:
#' `facet`, `clone_id`, `ident`, `val`
#' Useful for plotting with `ggplot2`
#' 
#' @examples
#' lst_pairs = list(c("PB_d28, "GC_d28"), c("PB_d28", "GC_d35"))
#' 
#' alluv_cols = c("PB_d28", "GC_d28", "GC_d35")
#' 
#' prep_for_paried_mf(lst_pairs, alluv_cols, alluv_df, alluv_lst_cl_id,
#'                    df_data=db, col_df_clone_id="clone_id_2",
#'                    col_df_mf, col_df_label="compartment_timepoint_2")
#' 
prep_for_paired_mf = function(lst_pairs, alluv_cols, alluv_df, alluv_lst_cl_id,
                              df_data, col_df_clone_id, col_df_mf, col_df_label) {
    
    vec_facets = unlist(lapply(lst_pairs, function(l){paste(l, collapse=" + ")}))
    
    # facet, clone id, ident, val
    lst_pairs_df_long = vector(mode="list", length=length(lst_pairs))
    
    # facet, clone id, a ident, b ident, a val, b val
    lst_pairs_df_wide = vector(mode="list", length=length(lst_pairs))
    
    for (i in 1:length(lst_pairs)) {
        
        cur_pair = lst_pairs[[i]]
        # facet
        cur_facet = paste(cur_pair, collapse=" + ")
        # a ident
        cur_a = cur_pair[1]
        # b ident
        cur_b = cur_pair[2]
        
        # rows in binary matrix
        cur_row_idx = which(alluv_df[[cur_a]] & alluv_df[[cur_b]])
        
        if (length(cur_row_idx)>0) {
            
            # clone id
            cur_clones = unlist(alluv_lst_cl_id[cur_row_idx])
            
            cur_n_clones = length(cur_clones)
            stopifnot(cur_n_clones==alluv_df[["count"]][cur_row_idx])
            
            if (cur_n_clones>0) {
                # long format
                cur_dfs_long = do.call(rbind, sapply(cur_clones, function(cl) {
                    
                    bool_cl = df_data[[col_df_clone_id]]==cl
                    # a val
                    cur_a_med = median(df_data[[col_df_mf]][bool_cl & df_data[[col_df_label]]==cur_a])
                    # b val
                    cur_b_med = median(df_data[[col_df_mf]][bool_cl & df_data[[col_df_label]]==cur_b])
                    
                    cl_df = data.frame(cbind(clone_id=rep(cl, 2), ident=cur_pair), 
                                       stringsAsFactors=F)
                    cl_df = cbind(cl_df, val=c(cur_a_med, cur_b_med))
                    
                    return(cl_df)
                    
                }, simplify=F))
                
                cur_dfs_long = cbind(facet=cur_facet, cur_dfs_long, stringsAsFactors=F)
                rownames(cur_dfs_long) = NULL
                
                # won't hold if db manually restricted to 10x or bulk only
                stopifnot(!is.na(cur_dfs_long))
                
                lst_pairs_df_long[[i]] = cur_dfs_long
                
                # wide format
                cur_dfs_wide_val = do.call(rbind, sapply(cur_clones, function(cl) {
                    
                    bool_cl = df_data[[col_df_clone_id]]==cl
                    # a val
                    cur_a_med = median(df_data[[col_df_mf]][bool_cl & df_data[[col_df_label]]==cur_a])
                    # b val
                    cur_b_med = median(df_data[[col_df_mf]][bool_cl & df_data[[col_df_label]]==cur_b])
                    
                    return(c(cur_a_med, cur_b_med))
                }, simplify=F))
                
                cur_dfs_wide_cols = c("facet", "clone_id", "a_ident", "b_ident", "a_val", "b_val")
                cur_dfs_wide = data.frame(matrix(NA, nrow=length(cur_clones),
                                                 ncol=length(cur_dfs_wide_cols)))
                colnames(cur_dfs_wide) = cur_dfs_wide_cols
                cur_dfs_wide[["facet"]] = cur_facet
                cur_dfs_wide[["clone_id"]] = cur_clones
                cur_dfs_wide[["a_ident"]] = cur_a
                cur_dfs_wide[["b_ident"]] = cur_b
                cur_dfs_wide[["a_val"]] = cur_dfs_wide_val[, 1]
                cur_dfs_wide[["b_val"]] = cur_dfs_wide_val[, 2]
                rownames(cur_dfs_wide) = NULL
                
                lst_pairs_df_wide[[i]] = cur_dfs_wide
            } else {
                cat("no clone containing both", cur_a, "and", cur_b, "; skipped.\n")
            }

        } else {
            stop("Unexpected error.")
        }
    }
    
    pairs_df_long = do.call(rbind, lst_pairs_df_long)
    pairs_df_wide = do.call(rbind, lst_pairs_df_wide)
    
    pairs_df_long[["facet"]] = factor(pairs_df_long[["facet"]], levels=vec_facets)
    pairs_df_wide[["facet"]] = factor(pairs_df_wide[["facet"]], levels=vec_facets)
    
    pairs_df_long[["ident"]] = factor(pairs_df_long[["ident"]], levels=alluv_cols)
    
    # /2 since every clone has two entries in long format
    stopifnot(all.equal( table(pairs_df_long[["facet"]])/2,
                         table(pairs_df_wide[["facet"]]) ))
    
    return(list(vec_facets=vec_facets,
                pairs_df_long=pairs_df_long,
                pairs_df_wide=pairs_df_wide))
}



#' Generate a data.frame for plotting median clonal mutation of UNPAIRED labels
#' For clones containing only ONE of a_ident and b_ident, but not both
#' 
#' Same input arguments and output formats as `prep_for_paired_mf`.
#' 
#' The differences in output are that
#' - In the wide format data.frame, for each clone, one of {a_ident, b_ident}
#'   is `NA` (since the clone only contains one of them, not both)
#' - The long format data.frame has the same number of rows (as opposed to double)
#'   as the wide format data.frame (since each clone only contains one of the two
#'   idents in lst_pairs, not both)
#' 
prep_for_nonpaired_mf = function(lst_pairs, alluv_cols, alluv_df, alluv_lst_cl_id,
                                 df_data, col_df_clone_id, col_df_mf, col_df_label) {
    
    vec_facets = unlist(lapply(lst_pairs, function(l){paste(l, collapse=" + ")}))
    
    # facet, clone id, ident, val
    lst_pairs_df_long = vector(mode="list", length=length(lst_pairs))
    
    # facet, clone id, a ident, b ident, a val, b val
    lst_pairs_df_wide = vector(mode="list", length=length(lst_pairs))
    
    for (i in 1:length(lst_pairs)) {
        
        cur_pair = lst_pairs[[i]]
        # facet
        cur_facet = paste(cur_pair, collapse=" + ")
        # a ident
        cur_a = cur_pair[1]
        # b ident
        cur_b = cur_pair[2]
        
        cur_lst_long = vector(mode="list", length=2)
        names(cur_lst_long) = c(cur_a, cur_b)
        cur_lst_wide = vector(mode="list", length=2)
        names(cur_lst_wide) = c(cur_a, cur_b)
        
        for (cur_ident in c(cur_a, cur_b)) {
            
            # rows in binary matrix
            if (cur_ident==cur_a) {
                cur_row_idx = which(alluv_df[[cur_a]] & !alluv_df[[cur_b]])
            } else {
                cur_row_idx = which(!alluv_df[[cur_a]] & alluv_df[[cur_b]])
            }
            
            if (length(cur_row_idx)>0) {
            
                # clone id
                cur_clones = unlist(alluv_lst_cl_id[cur_row_idx])
                
                cur_n_clones = length(cur_clones)
                stopifnot(cur_n_clones==alluv_df[["count"]][cur_row_idx])
                
                if (cur_n_clones>0) {
                    ### long format
                    cur_dfs_long = do.call(rbind, sapply(cur_clones, function(cl) {
                        
                        bool_cl = df_data[[col_df_clone_id]]==cl
                        # val
                        cur_ident_med = median(df_data[[col_df_mf]][bool_cl & df_data[[col_df_label]]==cur_ident])
                        
                        cl_df = data.frame(cbind(clone_id=cl, ident=cur_ident), 
                                           stringsAsFactors=F)
                        cl_df = cbind(cl_df, val=cur_ident_med)
                        
                        return(cl_df)
                        
                    }, simplify=F))
                    
                    stopifnot(nrow(cur_dfs_long)==length(cur_clones))
                    
                    cur_dfs_long = cbind(facet=cur_facet, cur_dfs_long, stringsAsFactors=F)
                    rownames(cur_dfs_long) = NULL
                    
                    # won't hold if db manually restricted to 10x or bulk only
                    stopifnot(!is.na(cur_dfs_long))
                    
                    cur_lst_long[[cur_ident]] = cur_dfs_long
                    
                    
                    ### wide format
                    cur_dfs_wide_val = do.call(rbind, sapply(cur_clones, function(cl) {
                        
                        bool_cl = df_data[[col_df_clone_id]]==cl
                        
                        if (cur_ident==cur_a) {
                            # expect there to be no cur_b 
                            stopifnot( sum(bool_cl & df_data[[col_df_label]]==cur_b)==0 )
                            
                            # a val
                            cur_a_med = median(df_data[[col_df_mf]][bool_cl & df_data[[col_df_label]]==cur_a])
                            cur_b_med = NA
                            
                        } else {
                            # expect there to be no cur_a 
                            stopifnot( sum(bool_cl & df_data[[col_df_label]]==cur_a)==0 )
                            
                            # b val
                            cur_a_med = NA
                            cur_b_med = median(df_data[[col_df_mf]][bool_cl & df_data[[col_df_label]]==cur_b])
                        }
                        
                        return(c(cur_a_med, cur_b_med))
                    }, simplify=F))
                    
                    cur_dfs_wide_cols = c("facet", "clone_id", "a_ident", "b_ident", "a_val", "b_val")
                    cur_dfs_wide = data.frame(matrix(NA, nrow=length(cur_clones),
                                                     ncol=length(cur_dfs_wide_cols)))
                    colnames(cur_dfs_wide) = cur_dfs_wide_cols
                    cur_dfs_wide[["facet"]] = cur_facet
                    cur_dfs_wide[["clone_id"]] = cur_clones
                    cur_dfs_wide[["a_ident"]] = cur_a
                    cur_dfs_wide[["b_ident"]] = cur_b
                    cur_dfs_wide[["a_val"]] = cur_dfs_wide_val[, 1]
                    cur_dfs_wide[["b_val"]] = cur_dfs_wide_val[, 2]
                    rownames(cur_dfs_wide) = NULL
                    
                    cur_lst_wide[[cur_ident]] = cur_dfs_wide
                    
                    # sanity check
                    # dimension
                    stopifnot(nrow(cur_dfs_long)==nrow(cur_dfs_wide))
                    # clone identities
                    stopifnot(all.equal( sort(cur_dfs_long[[col_df_clone_id]]),
                                         sort(cur_dfs_wide[[col_df_clone_id]]) ))
                    # mf associated w each clone
                    stopifnot(all.equal( cur_dfs_long[["val"]][order(cur_dfs_long[[col_df_clone_id]])],
                                         cur_dfs_wide[[ifelse(cur_ident==cur_a, "a_val", "b_val")]][order(cur_dfs_wide[[col_df_clone_id]])] ))
                } else {
                    cat("no clone containing only", cur_ident, "; skipped.\n")
                }
                
            } else {
                stop("Unexpected error.")
            }
        }
        
        cur_pair_df_long = do.call(rbind, cur_lst_long)
        cur_pair_df_wide = do.call(rbind, cur_lst_wide)
        lst_pairs_df_long[[i]] = cur_pair_df_long
        lst_pairs_df_wide[[i]] = cur_pair_df_wide
    }
    
    pairs_df_long = do.call(rbind, lst_pairs_df_long)
    pairs_df_wide = do.call(rbind, lst_pairs_df_wide)
    
    pairs_df_long[["facet"]] = factor(pairs_df_long[["facet"]], levels=vec_facets)
    pairs_df_wide[["facet"]] = factor(pairs_df_wide[["facet"]], levels=vec_facets)
    
    pairs_df_long[["ident"]] = factor(pairs_df_long[["ident"]], levels=alluv_cols)
    
    # expect equality since every clone has 1 entry in long format
    stopifnot(all.equal( table(pairs_df_long[["facet"]]),
                         table(pairs_df_wide[["facet"]]) ))
    
    return(list(vec_facets=vec_facets,
                pairs_df_long=pairs_df_long,
                pairs_df_wide=pairs_df_wide))
}


#' perform two-sided, paired, non-parametric Mann-Whitney for pairs_df_wide
#' adjust p-values to correct for multiple testing using `p_adj_method`
#' 
#' @params  vec_facets      Vector outputted by `prep_for_paired_mf`
#' @params  pairs_df_wide   Wide-format data.frame outputted by `prep_for_paired_mf`
#' @params  p_adj_method    Method for p-value adjustment. Passed to `p.adjust`.
#' 
#' @returns
#' A list containing two vectors, representing unadjusted and adjusted p-values.
#' The length of each vector matches that of `vec_facets`.
#' 
get_stat_paired_mf = function(vec_facets, pairs_df_wide, p_adj_method="BH") {
    
    # use wide format of df
    
    vec_p_unadj = rep(NA, length(vec_facets))
    names(vec_p_unadj) = vec_facets
    
    for (f in vec_facets) {
        
        cur_pairs_df_wide = pairs_df_wide[pairs_df_wide[["facet"]]==f, ]
        stopifnot(nrow(cur_pairs_df_wide)>0)
        
        cur_vec_a = cur_pairs_df_wide[["a_val"]]
        cur_vec_b = cur_pairs_df_wide[["b_val"]]
        
        if ((!all(is.na(cur_vec_a))) & (!all(is.na(cur_vec_b)))) {
            # non-parametric
            # paired
            
            # with default exact=NULL and correct=T, exact p-values are calculated where possible
            # if not possible, p-values are calculated using normal approximation w/ continuity correction
            cur_test = wilcox.test(x=cur_vec_a,
                                   y=cur_vec_b,
                                   alternative="two.sided",
                                   paired=T)
            cur_p = cur_test[["p.value"]]
            vec_p_unadj[f] = cur_p
            
            cur_med_a = median(cur_vec_a, na.rm=T)
            cur_med_b = median(cur_vec_b, na.rm=T)
            
            cat(f, "; n =", nrow(cur_pairs_df_wide), "; unadj p =", cur_p,"\n")
            cat("median a_val:", round(cur_med_a, 3), 
                "; median b_val:",  round(cur_med_b, 3), "\n")
        } else {
            cat(f, "; one or more categories have all NA values; skipped\n")
        }
    }
    
    cat("\nunadjusted p-values:\n")
    print(vec_p_unadj)
    
    vec_p_adj = p.adjust(p=vec_p_unadj, method=p_adj_method)
    
    cat("\nadjusted p-values; method =", p_adj_method, ":\n")
    print(vec_p_adj)
    
    return(list(vec_p_unadj=vec_p_unadj,
                vec_p_adj=vec_p_adj,
                p_adj_method=p_adj_method))
}

